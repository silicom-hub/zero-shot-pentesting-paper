import nasim
import numpy as np
import os
import copy

import gym
from gym import spaces

import sys
sys.path.append("./")


class Env_Nasim(gym.Env):
	"""Custom Environment of Nasim that can provide new reward and textual observation for NLP"""
	metadata = {'render.modes': ['human']}

	def __init__(self, env_name="tiny", mode="train", seed=13):
		super(Env_Nasim, self).__init__()

		self.env_name = env_name
		self.mode = mode

		if self.env_name == "custom":
			self.nasim = nasim.load("example/custom/medium_env_test.yaml", fully_obs=False)

		elif self.env_name == "tiny":
			self.nasim = nasim.load("example/nasim/tiny.yaml", fully_obs=False)

		elif self.env_name == "tiny-hard":
			self.nasim = nasim.load("example/nasim/tiny-hard.yaml", fully_obs=False)

		elif self.env_name == "small-linear":
			self.nasim = nasim.load("example/nasim/small-linear.yaml", fully_obs=False)

		elif self.env_name == "medium":
			self.nasim = nasim.load("example/nasim/medium.yaml", fully_obs=False)

		else:
			raise NotImplementedError

		# Reset the environment nasim
		self.nasim.reset()

		# Nasim transposition
		self.flat_actions = self.nasim.flat_actions
		self.action_space = self.nasim.action_space
		self.observation_space = self.nasim.observation_space

		# Memory of the env (to remember and focus of specific machine)
		self.memory_env, self.potential_link = self.init_memory_env()

		# Reward specific
		self.decision_taken_without_chance = []
		self.factor_bonus_information = 10

		self.ip_to_id, self.id_to_ip = self.init_id_machine()

		self.id_action_success = []

		self.privilege_on_progress = []
		self.previous_action_status = ""
		self.exploit_target_failed = []
		self.privilege_obtain = []
		self.privilege_cannot_be_obtain = []

		self.list_id_target = [self.ip_to_id[target] for target in self.nasim.network.get_sensitive_hosts()]
		self.description_goal = self._interpret_description()
		self.context = self._interpret_context()
		self.actions_runnable = self._interpret_actions_runnable()


	def init_memory_env(self):
		memory_env = dict()
		potentiel_link = []

		last_obs = self.nasim.last_obs.get_readable()[0]

		for data in last_obs:
			if data['Discovered'] == True and data['Reachable'] == True:
				ip = data['Address']
				memory_env[ip] = self.init_default_component()
				memory_env[ip]["discovered"] = True
				memory_env[ip]["reachable"] = True

				potentiel_link.append(ip)
		return memory_env, potentiel_link


	def init_default_component(self):
		intern_mem = dict()
		intern_mem["services"] = dict()
		intern_mem["processes"] = dict()
		intern_mem["os"] = dict()
		intern_mem["discovered"] = False
		intern_mem["reachable"] = False
		intern_mem["compromised"] = False
		intern_mem["root_obtain"] = False
		intern_mem["subnet_execute"] = False
		return intern_mem


	def init_id_machine(self):
		ip_to_id = dict()
		id_to_ip = dict()
		i = 'A'
		for ip in self.nasim.network.hosts.keys():
			ip_to_id[ip] = i
			id_to_ip[i] = ip
			i = chr(ord(i) + 1)
		return ip_to_id, id_to_ip


	def _interpret_description(self):
		list_id_link = []
		for target in self.potential_link:
			list_id_link.append(self.ip_to_id[target])

		# description_link = "%s are potentially link to %s." % (','.join(list_id_link), ','.join(self.list_id_target))
		description_link = "%s are potentially linked to %s." % (','.join(list_id_link), ','.join(self.list_id_target))
		# description_goal = "The goal is to get privilege on %s while remaining invisible. We encourage to continue attack machine where you have no full access." % (','.join(self.list_id_target))
		description_goal = "The goal is to get privileges on %s while remaining undetected. We encourage to keep attacking machines where you do not have full access." % (','.join(self.list_id_target))

		description_list = [description_link, description_goal]
		description_str = " ".join(description_list)

		return description_str


	def _interpret_context(self):
		interpret_context = dict()

		for ip in self.nasim.network.hosts.keys():

			if ip in self.memory_env.keys():

				# service
				if len(self.memory_env[ip]["services"]) > 0:
					service_context = "Error"
					service_available_list = []

					for service, status in self.memory_env[ip]["services"].items():
						if status == True:
							service_available_list.append(service)


					if len(service_available_list) > 0:
						service_available_str = ','.join(service_available_list)
						# service_context = "The service %s run on %s." % (service_available_str, self.ip_to_id[ip])
						service_context = "The service %s is running on %s." % (service_available_str, self.ip_to_id[ip])

					if service_context == "Error":
						print(self.memory_env[ip]["services"])
						raise NotImplementedError
				else:
					service_context = "No service found on %s." % (self.ip_to_id[ip])

				# operating system
				if len(self.memory_env[ip]["os"]) > 0:
					os_context = "Error"
					for os, status in self.memory_env[ip]["os"].items():
						if status == True:
							# os_context = "The operating system %s run on %s." % (os, self.ip_to_id[ip])
							os_context = "The operating system %s is running on %s." % (os, self.ip_to_id[ip])

					if os_context == "Error":
						print(self.memory_env[ip]["os"])
						raise NotImplementedError
				else:
					os_context = "No operating system found on %s." % (self.ip_to_id[ip])

				# process
				if len(self.memory_env[ip]["processes"]) > 0:
					process_context = "No process found on %s." % (self.ip_to_id[ip])
					for process, status in self.memory_env[ip]["processes"].items():
						if status == True:
							# process_context = "The process %s run on %s." % (process, self.ip_to_id[ip])
							process_context = "The process %s is running on %s." % (process, self.ip_to_id[ip])
				else:
					process_context = "No process found on %s." % (self.ip_to_id[ip])

				if self.memory_env[ip]["compromised"] == True:
					# privilege_context = "The compromission is done on %s." % (self.ip_to_id[ip])
					privilege_context = "%s is finally infected." % (self.ip_to_id[ip])
				else:
					privilege_context = "No privileges obtained on %s." % (self.ip_to_id[ip])

				description_goal = "The goal is to get privileges on %s while remaining undetected." % (','.join(self.list_id_target))
				context_list = [description_goal, service_context, os_context, process_context, privilege_context, self.previous_action_status]

				context_str = ' '.join(context_list)

				interpret_context[ip] = context_str
		return interpret_context


	def _interpret_actions_runnable(self):
		interp_runnable_action = dict()

		self.id_to_action = dict()
		id_cntr = dict()

		for id_action in range(self.nasim.action_space.n):
			name_action = self.nasim.action_space.get_action(id_action).name
			target_action = self.nasim.action_space.get_action(id_action).target

			if target_action not in interp_runnable_action.keys():
				interp_runnable_action[target_action] = []

			if target_action not in self.id_to_action.keys():
				self.id_to_action[target_action] = dict()

			if target_action not in id_cntr.keys():
				id_cntr[target_action] = 0

			if target_action in self.memory_env.keys() and id_action not in self.id_action_success:

				self.id_to_action[target_action][id_cntr[target_action]] = id_action
				id_cntr[target_action] += 1

				if name_action == "service_scan":
					action_room = "reveal service on %s" % (self.ip_to_id[target_action])
					interp_runnable_action[target_action].append(action_room)

				elif name_action == "os_scan":
					action_room = "reveal operating system on %s" % (self.ip_to_id[target_action])
					interp_runnable_action[target_action].append(action_room)

				elif name_action == "process_scan":
					# action_room = "reveal process through compromission on %s" % (self.ip_to_id[target_action])
					action_room = "reveal process by infecting %s" % (self.ip_to_id[target_action])
					interp_runnable_action[target_action].append(action_room)

				elif name_action == "subnet_scan":
					# action_room = "reveal subnet through compromission on %s" % (self.ip_to_id[target_action])
					action_room = "discover subnet by infecting %s" % (self.ip_to_id[target_action])
					interp_runnable_action[target_action].append(action_room)

				elif name_action == "e_ftp":
					os_target = self.nasim.action_space.get_action(id_action).os
					if os_target is None:
						raise NotImplementedError
					else:
						action_room = "exploit ftp %s on %s" % (os_target, self.ip_to_id[target_action])
						interp_runnable_action[target_action].append(action_room)

				elif name_action == "e_http":
					os_target = self.nasim.action_space.get_action(id_action).os
					if os_target is not None:
						raise NotImplementedError
					else:
						action_room = "exploit http on %s" % (self.ip_to_id[target_action])
						interp_runnable_action[target_action].append(action_room)

				elif name_action == "e_ssh":
					os_target = self.nasim.action_space.get_action(id_action).os
					if os_target is None:
						raise NotImplementedError
					else:
						action_room = "exploit ssh %s on %s" % (os_target, self.ip_to_id[target_action])
						interp_runnable_action[target_action].append(action_room)

				elif name_action == "e_samba":
					os_target = self.nasim.action_space.get_action(id_action).os
					if os_target is None:
						raise NotImplementedError
					else:
						action_room = "exploit samba %s on %s" % (os_target, self.ip_to_id[target_action])
						interp_runnable_action[target_action].append(action_room)

				elif name_action == "e_smtp":
					os_target = self.nasim.action_space.get_action(id_action).os
					if os_target is None:
						raise NotImplementedError
					else:
						action_room = "exploit smtp %s on %s" % (os_target, self.ip_to_id[target_action])
						interp_runnable_action[target_action].append(action_room)


				elif name_action == "pe_daclsvc":
					#action_room = "privilege escalation daclsvc on %s" % (self.ip_to_id[target_action])
					#action_room = "get root privilege windows through compromision on %s" % (self.ip_to_id[target_action])
					#action_room = "privilege escalation on daclsvc windows through compromision on %s" % (self.ip_to_id[target_action])
					# action_room = "get root privileges daclsvc windows through compromision on %s" % (self.ip_to_id[target_action])
					action_room = "get highest privileges by infecting %s with daclsvc windows" % (self.ip_to_id[target_action])
					interp_runnable_action[target_action].append(action_room)


				elif name_action == "pe_tomcat":
					#action_room = "privilege escalation tomcat on %s" % (self.ip_to_id[target_action])
					#action_room = "get root privilege linux through compromision on %s" % (self.ip_to_id[target_action])
					#action_room = "privilege escalation on tomcat linux through compromision on %s" % (self.ip_to_id[target_action])
					# action_room = "get root privileges tomcat linux through compromision on %s" % (self.ip_to_id[target_action])
					action_room = "get highest privileges by infecting %s with tomcat linux" % (self.ip_to_id[target_action])
					interp_runnable_action[target_action].append(action_room)


				elif name_action == "pe_schtask":
					#action_room = "privilege escalation on schtask windows through compromision on %s" % (self.ip_to_id[target_action])
					# action_room = "get root privileges schtask windows through compromision on %s" % (self.ip_to_id[target_action])
					action_room = "get highest privileges by infecting %s with schtask windows" % (self.ip_to_id[target_action])
					interp_runnable_action[target_action].append(action_room)

				else:
					print(name_action)
					raise NotImplementedError

		return interp_runnable_action


	def goal_reached(self):
		return self.nasim.goal_reached()


	def step(self, action):

		name_action = self.nasim.action_space.get_action(action).name
		target_action = self.nasim.action_space.get_action(action).target

		# next_obs, reward, done, step_limit, info = self.nasim.step(action)
		next_obs, reward, done, info = self.nasim.step(action)

		# if we reached an goal (Must be improved for other scenario because it's very bad)
		if reward > 90.0:
			if self.ip_to_id[target_action] in self.list_id_target:
				self.list_id_target.remove(self.ip_to_id[target_action])

		# Check if the target action is on progress, and not privilege obtain, or privilege cannot be obtain
		if (target_action not in self.privilege_on_progress) and (target_action not in self.privilege_obtain) and (target_action not in self.privilege_cannot_be_obtain):
			self.privilege_on_progress.append(target_action)


		# If action success, then remove from available action and clear the past action
		if info["success"] == True:
			self.id_action_success.append(action)
			self.previous_action_status = ""


		# Check if the decision was taken with the knowledge
		if name_action == "e_ssh" or name_action == "e_ftp" or name_action == "e_http" or name_action == "e_samba" or name_action == "e_smtp":
			if info["success"] == True:
				if len(self.memory_env[target_action]["services"]) > 0:
					if action not in self.decision_taken_without_chance:
						self.decision_taken_without_chance.append(action)
		elif name_action == "pe_tomcat" or name_action == "pe_daclsvc" or name_action == "pe_schtask":
			if info["success"] == True:
				if len(self.memory_env[target_action]["processes"]) > 0:
					if action not in self.decision_taken_without_chance:
						self.decision_taken_without_chance.append(action)


		# Check if the exploitation success (BUG: Need to confirm that the exploit has the correct name ??)
		if name_action == "e_ssh" or name_action == "e_ftp" or name_action == "e_http" or name_action == "e_samba" or name_action == "e_smtp":
			if info["success"] == True:
				self.memory_env[target_action]["compromised"] = True

			# If action failed due to permission error
			elif info["permission_error"] == True:
				if self.previous_action_status != "":
					self.exploit_target_failed.append(target_action)
				else:
					service_action = self.nasim.action_space.get_action(action).service
					os_action = self.nasim.action_space.get_action(action).os

					if os_action == None:
						self.previous_action_status = "The previous action about %s has failed." % (service_action)
					else:
						self.previous_action_status = "The previous action about %s %s has failed." % (service_action, os_action)


		# Check if we have privilege then nothing to add
		if name_action == "e_ssh" or name_action == "e_ftp" or name_action == "e_http" or name_action == "e_samba" or name_action == "e_smtp" or name_action == "pe_tomcat" or name_action == "pe_daclsvc" or name_action == "pe_schtask":
			privilege_level = self.nasim.action_space.get_action(action).access
			if info["success"] == True and privilege_level == 2:
				self.memory_env[target_action]["root_obtain"] = True
				# if target_action in self.privilege_on_progress:
				#	self.privilege_on_progress.remove(target_action)
				# self.privilege_obtain.append(target_action)

		if name_action == "subnet_scan":
			if info["success"] == True:
				self.memory_env[target_action]["subnet_execute"] = True


		if target_action in self.memory_env.keys():
			if self.memory_env[target_action]["root_obtain"] == True and self.memory_env[target_action]["subnet_execute"] == True:
				if target_action in self.privilege_on_progress:
					self.privilege_on_progress.remove(target_action)
				self.privilege_obtain.append(target_action)


		# Check if the sensitive host is in the list of new discovery ?
		if len(info["newly_discovered"]) > 0:
			for ip, status in info["newly_discovered"].items():

				# if we launch subnet scan then add it
				if self.memory_env[target_action]["subnet_execute"] == False:
					self.memory_env[target_action]["subnet_execute"] = True

				# if discover new path, then permit to retarget the action
				if ip in self.exploit_target_failed:
					if ip in self.exploit_target_failed:
						self.exploit_target_failed.remove(ip)

				if status == True:
					self.potential_link.append(ip)

					self.memory_env[ip] = self.init_default_component()
					self.memory_env[ip]["discovered"] = True
					self.memory_env[ip]["reachable"] = True

			# if discover new machine no need to past time on the current machine.
			if target_action in self.potential_link:
				self.potential_link.remove(target_action)


		# Check if we discover new services
		if len(info["services"]) > 0:
			for service, status in info["services"].items():
				if service not in self.memory_env[target_action]["services"]:
					self.memory_env[target_action]["services"][service] = status

		# Check if we discover new os
		if len(info["os"]) > 0:
			for os, status in info["os"].items():
				if os not in self.memory_env[target_action]["os"]:
					self.memory_env[target_action]["os"][os] = status

		# Check if we discover new processes
		if len(info["processes"]) > 0:
			process_found = False
			for process, status in info["processes"].items():
				if status == 1.0:
					process_found = True
				if process not in self.memory_env[target_action]["processes"]:
					self.memory_env[target_action]["processes"][process] = status


			services = self.memory_env[target_action]["services"]
			service_found = False
			if "samba" in services.keys():
				if services["samba"] == 1.0:
					service_found |= True
			if "ftp" in services.keys():
				if services["ftp"] == 1.0:
					service_found |= True

			subnet_execute = self.memory_env[target_action]["subnet_execute"]

			# Check if we discover no process on machine when we run process_scan
			if process_found == False and service_found == False and subnet_execute == True:
				if target_action not in self.privilege_obtain:
					if target_action in self.privilege_on_progress:
						self.privilege_on_progress.remove(target_action)
					self.privilege_cannot_be_obtain.append(target_action)


		self.description_goal = self._interpret_description()
		self.context = self._interpret_context()
		self.actions_runnable = self._interpret_actions_runnable()
		
		if self.mode == "eval":
			if done:
				print("Reward (before bonus) = %d" % reward)
				print("Number of decision taken without chance = %d " % len(self.decision_taken_without_chance))
				bonus = len(self.decision_taken_without_chance) * self.factor_bonus_information
				reward += bonus
				print("Reward (after bonus) = %d" % reward)
			else:
				bonus = 0
		else:
			bonus = 0

		# return next_obs, reward, done, step_limit, info
		return next_obs, reward, done, info


	def reset(self):

		# Reset env
		obs = self.nasim.reset()

		# Memory of the env (to remember and focus of specific machine)
		self.memory_env, self.potential_link = self.init_memory_env()

		# Reward specific
		self.decision_taken_without_chance = []
		self.factor_bonus_information = 10

		self.ip_to_id, self.id_to_ip = self.init_id_machine()

		self.id_action_success = []

		self.privilege_on_progress = []
		self.previous_action_status = ""
		self.exploit_target_failed = []
		self.privilege_obtain = []
		self.privilege_cannot_be_obtain = []

		self.context = self._interpret_context()
		self.actions_runnable = self._interpret_actions_runnable()

		return obs


	def render(self, render_mode=None):
		if render_mode == "readable":
			self.nasim.render("readable")
		else:
			self.nasim.render()


	def close(self):
		self.nasim.close()